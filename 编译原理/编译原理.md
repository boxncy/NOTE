# 信息表示 数据变换

## 编译的每个部分要放到整个编译过程中来看，他为先后都提供了什么？

需要学习：正规表达式、有穷自动机、上下文无关文法、结合论、形式语言与自动机

编译实际是翻译程序，源程序 -> 目标程序

- 解释程序

逐句翻译与，一边解释一边翻译 ： 源程序 -> 解释程序 -> 输出结果

整篇翻译： 源程序 -> **编译程序** -> 目标程序

- 编译系统

编译系统 = 编译程序 + 运行系统（dll）

- 其他的翻译程序

汇编、反汇编、交叉编译、交叉汇编...

## 编译的整个过程

- 词法分析，找到所有的单词
- 语法分析，组词成句，根据给定的语法规则验证源代码的结构是否符合语法规范。
- 语义分析，分析类型、地址等正确与否，检查代码的语义合法性
- 中间代码生成，方便移植与优化
- 中间代码优化
- 生成目标代码

**对于符号表的维护与出错处理，在编译的整个过程中**

### 编译过程的分类  8个模块

- 分析：词法分析、语法分析、语义分析
- 综合：中间代码生成、代码优化、目标代码生成
- 辅助：符号表管理、出错处理

### 词法分析

- 输入是源程序：字符串
- 输出是单词（token）：（种别码， 属性值）序列

例：

```cpp
int sum = (10 + 20) * (num1 + num2);
```

单词有：

```
sum = (10 + 20) * (num1 + num2);
```

输出为：

```
(标识符，sum), (赋值号， =), (左括号， (), (整常数, 10),
(加号， +), (整常数， 20), (右括号， )), (乘号， *),
(右括号，(), (标识符， num1), (加号， +), (标识符， num2),
(左括号， )), (分号， ;)
```

将所有的变量抽象这样的二元组数据结构

- 词法分析由词法分析器完成
- 词法分析器从左到右扫描源程序字符串；并将其转换成token串；查词法错误；进行标识符登记——符号表管理

> 自动机是词法分析器中最常用的技术之一，它可以根据词法规则来扫描源代码，并将源代码转换成一个个的单词（Token）。
>
> 一般来说，自动机的过程可以分为以下几个步骤：
>
> 1. 定义词法规则：需要定义每个单词的格式和组成方式，例如关键字、运算符、标识符等。通常采用正则表达式或有限状态自动机（Finite State Machines，FSM）来表示。
> 2. 将词法规则转化为有限状态自动机：自动机是一个状态转换图，其中每个状态代表了当前词法分析处理的环节，而状态之间的转移通过输入的字符驱动，表示分析器如何从当前状态下一个状态。
> 3. 执行自动机：自动机从输入流中读取字符，同时在状态图中记录当前的状态，通过状态转移判断是否已经扫描到一个单词的结束位置。
> 4. 输出 Token：如果自动机执行到某个接受状态，就意味着已经匹配到了一个完整的单词，此时需要输出相应的 Token。Token 包含了单词的类型（例如关键字、标识符、运算符等）和值（单词本身的文本形式），作为语法分析的输入。
> 5. 处理错误情况：如果遇到了一个无法识别的字符或者其他错误情况，需要向错误处理程序发送一条错误信息。
>
> 总体来说，自动机实现词法分析时，采用状态转移的方式从输入流中识别出所有合法单词，并输出对应的 Token。这是编译器的第一个重要步骤，能够将源代码转换成可被语法分析器直接使用的形式，为后续步骤提供基础支持。

### 语法分析

- 实现组词成句：表达式、语句、子程序...（将词拼接为各种语句）
- 构造分析树
- 指出语法错误
- 制导翻译

- 输入是token序列
- 输出是语法树

例：

```cpp
int sum = (10 + 20) * (num1 + num2);
```

![屏幕截图 2023-10-19 221743](\GRATH\编译原理\graph\屏幕截图 2023-10-19 221743.png)

### 语义分析

检查具体类型

- 一般与语法分析同时进行，称为语法制导翻译（识别出一个语法成分，马上进行翻译，如果有标识符则**存到符号表**），分析语法分析出来的语义
- 获取标识符属性、类型、作用域（符号表一般通过作用域管理标识符，因为有可能重名）
- 检查运算合法性、取值范围 （这个类型能不能这么写，**去符号表查**）
- 子程序静态绑定：代码相对地址
- 变量静态绑定：数据相对地址

> 子程序静态绑定和变量静态绑定都是语义分析过程中的重要环节，它们对于程序的正确性和可靠性具有重要作用。
>
> 1. 子程序静态绑定
>
> 子程序静态绑定是指在程序编译或解释前确定子程序调用时所绑定的子程序实体，即静态绑定在编译时期完成。在语义分析中，进行子程序静态绑定可以将调用子程序和被调用子程序之间建立起关联关系，以确保程序可以正确执行。具体来说，子程序静态绑定主要有以下作用：
>
> - 确定被调用子程序的参数个数、类型和返回值类型。
> - 为子程序实体分配存储空间。
> - 进行参数匹配以及参数类型检查。
> - 进行子程序调用的各种检查，如是否存在歧义、是否存在递归调用等。
>
> 1. 变量静态绑定
>
> 变量静态绑定是指在程序编译或解释前确定变量所绑定的存储空间，即静态绑定在编译时期完成。在语义分析中，进行变量静态绑定可以将程序中的变量名与其对应的数据类型和存储空间建立起关联关系，以确保程序可以正确地获取和操作变量。具体来说，变量静态绑定主要有以下作用：
>
> - 确定变量的数据类型。
> - 为变量分配存储空间。
> - 进行类型匹配以及类型检查。
> - 进行变量作用域的管理。
>
> 综上所述，子程序静态绑定和变量静态绑定是语义分析过程中不可或缺的部分，它们可以确保程序在编译或解释时可以正确地处理子程序调用和变量操作，从而保证程序的正确性和可靠性

> 在编译过程中，编译器会根据语义分析的结果和语言规范确定子程序和变量的存储位置和属性，并将相关信息保存在符号表中。这些信息可能包括标识符的名称、类型、作用域等。而符号表可以作为数据结构的一部分存储在目标文件中的特定段（如.data段、.text段）中，以便在后续的链接和加载过程中使用。
>
> 对于子程序来说，编译器会将其实体（即子程序的代码）放置在目标文件的.text段或类似的代码段中，同时在符号表中为该子程序添加相关的属性，如名称、地址等。
>
> 对于变量来说，编译器会根据其作用域和存储要求将其放置在目标文件的.data段或类似的数据段中，同时在符号表中为该变量添加相关的属性，如名称、地址等。
>
> 需要注意的是，具体的存储方式和目标文件格式可能因编程语言、系统平台和编译器的不同而有所差异。因此，在不同的情况下，子程序和变量的存储位置和属性可能会有所不同，但总体上可以理解为通过符号表将它们与目标文件的特定段关联起来。

### 中间代码生成

例：

```cpp
int sum = (10 + 20) * (num1 + num2);
```

后缀表示：

```
sum 10 20 + num1 num2 + * =
```

前缀表示：

```
= sum * + 10 20 + num1 num2
```

或语法树表示、**四元式表示**

- 简单规范、中间代码与机器无关、易于优化与转换

> 中间代码是在编译过程中生成的一种抽象的、与具体机器无关的代码表示形式。它位于源代码和目标代码之间，具有高级语言和目标机器语言之间的中间形式。中间代码的生成是为了在不同的编译阶段进行优化和分析，以提高程序的性能和可读性。
>
> 相比于源代码和目标代码，中间代码通常更接近源代码的结构，但又已经去除了一些高级语言特定的语法和细节。中间代码可以采用不同的表示形式，例如三地址码、四元式、语法树等。
>
> 与中间代码相比，汇编代码则更接近目标机器语言。汇编代码是将高级语言翻译成目标机器语言的一种形式，它包含了特定机器指令的助记符和操作数，依赖于具体的硬件平台。
>
> 在编译过程中，中间代码是在源代码经过词法分析、语法分析和语义分析等阶段之后生成的，而汇编代码是在中间代码优化和目标代码生成之后生成的。
>

> 中间代码易于优化与转换的原因有以下几点：
>
> 1. 抽象性：中间代码是在源代码和目标代码之间的一种表示形式，它具有一定的抽象性。相比于源代码，中间代码已经去除了一些高级语言特定的语法和细节，但又保留了与程序逻辑相关的结构信息。这种抽象性使得优化器能够更轻松地对代码进行分析和优化，而不用处理源代码中的各种语法和语义细节。
> 2. 中立性：中间代码是与具体机器无关的表示形式，它与目标机器的硬件和指令集无关。这种中立性使得优化器能够基于通用的规则和算法对代码进行优化，而不需要考虑特定机器的细节。同时，中立性还使得中间代码可以在不同的目标平台上进行转换和优化。
> 3. 结构性：中间代码通常更接近源代码的结构，但已经去除了冗余和冗长的部分。中间代码的结构性使得优化器能够更容易地理解和操作代码的控制流和数据流，从而进行各种优化，如常量传播、公共子表达式消除、循环优化等。
> 4. 可扩展性：由于中间代码是在编译器的中间阶段生成的，它可以作为优化和转换的基础进行多次迭代。编译器可以在生成中间代码后应用各种优化技术，并在生成最终目标代码之前对中间代码进行转换。这种可扩展性使得编译器能够在不同的阶段对代码进行多层次的优化，从而提高程序的性能和效率。
>
> 综上所述，中间代码易于优化与转换的原因主要是由于其抽象性、中立性、结构性和可扩展性。这些特点使得优化器能够更轻松地对代码进行分析和优化，同时也为编译器提供了灵活性和可移植性。

### 代码优化

- 与机器有关代码
- 与机器无关代码

生成等价代码，但效率更高、更短

局部：

- 常量合并
- 公共表达式提取

循环·：

- 强度削减：用快操作提代码操作（如用x*x代替x方，加法替代乘法）

> x * x 比 x 方计算快是因为计算机硬件对乘法运算的支持更加高效。
>
> 计算 x 方需要进行一次乘法运算和一次存储操作，即将 x 的值存放到某个内存位置。而计算 x * x 也需要进行一次乘法运算，但不需要进行存储操作，因为计算机会将中间结果暂存到寄存器中。在多级缓存的计算机系统中，寄存器的访问速度比内存的访问速度更快，因此计算 x * x 要比计算 x 方更快。

- 代码外提：将循环内不变计算移出循环

与机器有关优化：

- 寄存器利用：将常量放入寄存器
- 体系结构
- 存储策略

### 目标代码生成

将中间代码转化成汇编代码或机器指令代码，主要是确定使用寄存器的策略和指令序列

- 确定源语言各种语法成分的目标代码结构（机器指令组/汇编语句组）
- 制定从中间代码到目标代码的翻译策略或算法

目标代码形式

- 有绝对地址的机器指令
- 汇编语言形式的目标程序
- 模块结构的机器指令（可重定位机器指令，需要链接程序）

### 表格管理

管理各种符号表（就是管名字，词法分析时，名字就有了，但是没有地址类型等，但是也要建立符号表，后续再补充）

- 辅助语法检查，语义检查
- 完成静态绑定、管理编译过程
- hash、链表等各种表的查、填技术（数据结构的应用）

### 错误处理

- 词法 拼写

- 语法 括号不配对 if 没 else

- 语义 参数、类型不匹配

## 编译程序的组织

- 前端：与源语言有关与目标机器无关

包括：词法分析，语法分析，语义分析，中间代码生成，与机器无关的代码优化

- 后端：与机器有关部分

包括：与目标机器有关的代码优化、目标代码生成

### 如何实现编译器

当世界上没有任何编译器时，一个c程序只能由人来完成到机器语言的翻译，也就是用机器语言来实现了编译器a用于编译c语言到机器语言，当有了编译器a，我就可以使用c语言编写编译器并用a来编译出编译器b，这个过程叫做**自举**

**移植**：当a机器有编译器，b机器没有，怎么办？应该实现一个将a机器语言翻译成b机器语言的翻译器，然后连接到c语言编译c语言为a机器语言的编译器后

**T形图**: L语言实现了一个L语言到B语言的编译器，但是B机器用不了，将编译器转换为A语言，就得到了一个LAB编译器,再将LLB通过LAB转化为LBB,B机器就能用了

```
L     B          L      B
   L	L     	A	A
   			A
```

```
L     B          L      B
   L	L    	B	B
   			A
```

### 词法分析器的自动生成 LEX

输入：

- 词法（正规表达式）

- 识别动作（c语言描述）

输出：

- 词法分析结果

### 语法分析器的自动生成  YACC

输入：

- 语法规则（产生式）

- 语义动作（c语言描述）

输出：

- 语法分析表达式

> 当我们学习一门语言时，需要遵循一定的语法规则才能正确地表达自己的意思。同样的，计算机语言也有自己的语法规则，这些规则可以用产生式来描述。
>
> 产生式就像是一条指导我们如何构造符合语法规则的语句的路线图。它由两部分组成：左部和右部。左部表示要构造的语句的一部分，右部则是一系列可以用来替换左部的符号或序列。
>
> 举个例子，假设我们有一个产生式：
>
> ```
> 复制代码S -> aSb
> ```
>
> 这个产生式告诉我们，如果我们想要构造一个符合语法规则的语句 S，我们可以先加上一个 a，然后再构造一个符合语法规则的语句 S，最后再加上一个 b。这个过程可以反复进行，直到我们构造出了一个完整的符合语法规则的语句。
>
> 产生式是编译器设计、自然语言处理、人工智能等领域中非常重要的概念。通过定义适当的产生式规则，我们可以描述和生成符合特定语法结构的字符串，从而实现对语言的理解和处理。

## 形式语言

- 语言的本质：信息交流的基础是按照共同约定的生成规则和理解规则去生成和理解句子
- 计算机中严格的语法和语义
- 计算机能处理的语言：符号、严格准确形式化的描述

语言(language)：满足一定条件的句子集合

句子(sentence)：满足一定条件的单词序列

单词(token)：满足一定规则的字符

### 文法的组成

由以下内容组合成语言

- 字母表
- 状态机
- 开始的符号
- 产生式集合

### 语法的描述方法

- BNF范式
- 语法图

### 单词的描述方法

- BNF范式
- 正规式
- 有穷自动机

### CFG上下文无关文法 

### 字母表

- 字母组成的集合（AQCII等)

- 字母表可以相乘获得乘积，所以同一个字母表也有幂的概念

- 闭包指对于一个给定的字母表，通过对该字母表中的符号进行一系列操作（如取反、连接、重复等），可以得到包含原始字母表中所有字符串的新字母表。

  例如，假设有一个字母表{a, b}，那么它的闭包可以包含以下字符串：

  - 空字符串ε
  - 单个字符a或b
  - 两个字符的字符串aa、ab、ba或bb
  - 三个字符的字符串aaa、aab、aba、abb、baa、bab、bba或bbb
  - 以此类推，直到包含所有可能的字符串

  可以使用正则表达式或其他形式的语法来表示一个字母表的闭包。闭包在计算机科学中有广泛的应用，例如在编译器设计、自然语言处理和密码学等领域中。

### 如何实现语言结构的形式化描述

如一个句子：左部量 = 右部表达式

如何对他符号化？

非终结符号V (代表语言各种子结构)

- 赋值语句
- 左部量
- 右部表达式
- 简单变量
- 下表变量
- 运算符

终结符号集T（组成语句的最小符号集合）

- {A,B,C,+,=,-,M[1]}...

语法规则集P  (语法规则组成的集合)

- 开始符号S  = 赋值语句...

开始符号集S 

**文法**：句子G = {V,T,P,S} 或者**自动机**

https://www.zhihu.com/question/439949994/answer/2886154926 （文法的实现）

对一个文法，只要列出他所有的产生式，且第一个产生式的左部是该文法的开始符号，就可以产生所有句子（推导、派生，倒过来就是规约）**重要！！**，利用派生和规约分别可以得到自顶向下语法分析和自底向上语法分析

p5 22：40