## 兼容

### 宏定义

```c++
1.__func__ //返回函数名
const char* text(){
	return __func__; // text
}
//一种用法
struct textBlock{
    textBlock(): name(__func__){}
    const char* name;
}
textBlock a;
a.name; // textBlock

2.__STDC_HOSTED__ //包含c库则为1，否则为0
    
3.__cplusplus //可以被#include到c文件中编译
通常配合extern "c" 
    如：
    #ifdef __cplusplus
    extern "c"{
    #endif
    //一些代码
}
extern "c"可以抑制c++对函数名、变量名等符号进行
    名称重整（name mangling）
    mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。
```

### _Pragma操作符

```c++
#pragma = _Pragma
#pragma once = _Pragma("once")
```

### 宽窄字符的连接

```c++
//支持char to wchar_t
```

#### 宽窄字符的区别是一个字符所占字节决定的，

窄字符1字节，宽字符通常为2字节

UTF8使用1-4个字节表示字符

UTF16使用2-6个字节表示字符(unicode)

所以UTF8与ASCII（窄字符）的编码相同

不同操作系统宽窄字符也不同

string = char[] , wstring =  wchar_t[]

### long long整形

#### 关于转换的优先级

整形提升从长度短到长度长，int -> long long int

由拓展类型到标准类型, _int64 -> long long int

有符号无符号相同, unsigned int = int

### 断言

预处理时和运行时

assert（运行时）

static_assert（预处理时）

static_assert(断言表达式，警告)；

### noexcept 

```
void !abc() noexcept;
```

### sizeof

### final&override

final一般再子类虚函数后，防止孙子类重写

override写在子类虚函数后，如果基类有该虚函数，不重载则报错

### 模板函数的默认模板参数

c++11新增,c98不允许

```c++
template <typename T = int>
void fun(T){};
```

### 外部模板

配合extern使用

```c++
template <typename T>  void func(T){}
//A文件显示的实例化
template void func<T>(T);
//B文件做外部模板声明
extern template void func<T>(T);
```

使用extern这样做的好处是，编译时模板函数不会额外实例化一次，同时链接时，由于只实例化一次，也不会再多一步消除重复实例化的过程

### 局部和匿名类型做模板实参

