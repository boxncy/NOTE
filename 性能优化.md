 在C++中，`volatile`关键字指示编译器一个变量的值可能以编译器无法预测的方式被改变。这通常用于两种情况：

1. **硬件寄存器访问**：当变量对应于硬件设备的状态或寄存器时，这些状态可能会由外部事件（如硬件中断）改变，而不是由程序直接控制。`volatile`确保每次访问变量时都会重新从其地址读取值，而不使用可能已经过时的缓存值。
2. **多线程程序中的共享变量**：在多线程环境中，一个线程可能修改另一个线程可以访问的变量。使用`volatile`可以告诉编译器不要对这些变量的访问进行优化，以确保变量的读/写操作直接映射到内存。

### 重要性和限制

- **避免编译器优化**：`volatile`关键字阻止编译器对变量的访问进行某些优化，比如将变量值缓存在寄存器中而不是每次都从内存地址读取。这确保了程序能够看到变量的最新值。
- **内存顺序保证**：在C++11及以后的版本中，`volatile`本身并不提供多线程程序中对变量访问的任何内存顺序保证。它不保证原子操作或者内存屏障。对于多线程同步，应该使用标准库中的原子操作和同步原语，如`std::atomic`。
- **用途限制**：`volatile`适用于那些可能由程序外部改变的变量。对于需要内存顺序或原子操作保证的场景，应使用C++11引入的原子操作。

### 结论

虽然`volatile`在特定情况下非常有用，但它并不适用于所有并发编程的需求。在现代C++中，对于并发和多线程编程，推荐使用标准库提供的原子操作和同步机制来确保数据一致性和内存顺序。

## 防止优化技巧

- 使用全局变量+锁
- __attribute__((noinline))防止内联
- 使用防止优化函数如: benchmark::DoNotOptimize
- 使用内存屏障如：加锁防止编译器打乱程序执行顺序

## Meyers' Singleton

Meyers' Singleton 是一种使用局部静态变量实现的单例模式。由Scott Meyers 提出，它是实现单例模式的一种有效且线程安全的方式（在C++11及以后的版本中）。相较于传统的单例实现方式，Meyers' Singleton 提供了更简单、更安全的单例实现。**函数内初始化一个静态变量，返回值返回该变量引用**，**保证初始化的线程安全，对于读是满足的，如果需要写则需要额外的操作**

### 特点

- **延迟初始化**：单例实例只有在首次使用时才会被创建。
- **局部静态变量**：使用函数内的局部静态变量来存储单例实例。
- **线程安全**：在C++11标准中，局部静态变量的初始化是线程安全的，这意味着在多线程环境中，单例的创建过程自动被保护。

### 实现方式

以下是Meyers' Singleton的一个典型实现示例：

```
cppCopy codeclass Singleton {
public:
    // 禁止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 提供一个访问单例的全局访问点
    static Singleton& getInstance() {
        static Singleton instance; // 局部静态变量
        return instance;
    }

    // 示例方法
    void doSomething() {
        // 实现细节...
    }

private:
    // 私有构造函数确保不能从外部创建实例
    Singleton() {}
};

// 使用示例
int main() {
    Singleton& singletonInstance = Singleton::getInstance();
    singletonInstance.doSomething();
    return 0;
}
```

### 优点

- **简洁性**：相比于其他单例实现，Meyers' Singleton更加简洁，易于理解和使用。
- **自动销毁**：实例在程序结束时自动销毁，不需要手动管理生命周期。
- **线程安全**：C++11保证了静态局部变量的线程安全初始化，无需额外的同步机制。

### 缺点

- **不可控的销毁顺序**：静态局部变量的销毁顺序可能会导致使用已销毁对象的风险，尤其是在涉及到多个单例或全局静态对象相互依赖时。

Meyers' Singleton是实现单例模式的一种高效、线程安全的方式，特别是在C++11及以后的环境中。它通过简单的方式解决了多线程环境下的单例实例化问题，使得单例模式的实现更加安全和易于维护。

## 关于static的声明

`static`关键字在这个上下文中限定了变量的链接可见性为仅限于定义它的翻译单元（即`.cpp`文件及其包含的所有头文件），尽管每个`.cpp`文件中的变量看起来是通过同一个头文件声明的，但实际上它们是分别存储和管理的不同实例。

### 如何解决？

如果你希望在多个`.cpp`文件之间共享一个全局变量，而不是为每个`.cpp`文件创建一个独立的副本，你应该在头文件中使用`extern`关键字来声明变量，而在一个（且仅一个）`.cpp`文件中定义它。这样，所有包含了该头文件的`.cpp`文件都会引用到同一个变量实例。

## gperftools

string+=与string pushback效率

对于string或者任何可能扩容的操作，在循环前提前进行扩容效果可能很好

虚函数会防止内联，这是主要的性能问题

函数调用和虚函数调用的额外开销（能内联最好内联）性能：内联>非内联非虚<虚函数

析构函数默认noexcept，移动构造，移动拷贝，swap函数需要标明

## string性能比较

string a = a + b性能比 a+= b差

如果知道size可以提前分配内存

传入const&

可以拿到data()然后替换需要插入的值，而不是pushback，这样减少了/0的写入

## vector

- 内存分配时，元素使用移动构造的话，必须要声明为noexcept
- 当元素还未构造时push_back可以被 emplace_back替换，一个是拷贝一个是new，一般来说emplace_back可以替换push_back，但是有可能比push_back对一种obj&的构造，倒是二进制文件变大
- reserve一次性设定内存大小，减少自动内存分配
- 尽量避免insert erase 以免移动元素

## deque

## list

## forward_list

## 关联容器（红黑树）

## 无序关联容器（hash）

## array