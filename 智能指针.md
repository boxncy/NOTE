## 智能指针

智能指针是为了管理不自动释放的堆对象，不要用它管理栈对象

### std::auto_ptr

**不使用**

auto_ptr在 等号赋值、拷贝构造时将会把自身的堆对象转移给被赋值指针，使赋值的指针在赋值后指向null。列如，将auto_ptr放在容器中时，很难保证算法对容器的操作不会对其进行赋值传递。

### std::unique_ptr 

对一块堆内存的**唯一所有权**，不可赋值给其他对象，销毁时同时销毁对应堆内存

```c++
//三种初始化方式
std::unique_ptr<int> p1(new int(11));

std::unique_ptr<int> p2;
p2.reset(new int(22));
//尽量使用第三种（c++14,或自己实现）
std::unique_ptr<int> p3 = std::make_unique<int>(33);


//不可进行 =赋值 和 拷贝（实现时内部就写了一个delete），只能通过移动构造传递内存
std::unique_ptr<int> p4 =std::move(p3);
//unique_ptr移动构造伪代码
template <typename T, typename Deletor>
class unique_ptr
{
    //其他函数省略...
public:
    unique_ptr(unique_ptr &&rhs)
    {
        this->m_pT = rhs.m_pT;
        //源对象释放
        rhs.m_pT = nullptr;
    }

    unique_ptr &operator=(unique_ptr &&rhs)
    {
        this->m_pT = rhs.m_pT;
        //源对象释放
        rhs.m_pT = nullptr;
        return *this;
    }

private:
    T *m_pT;
};

//unique_ptr常用函数
//释放当前由unique_ptr管理的内存（如果有），并获得参数p的所有权，如果p为空则unique_ptr为空
void reset(pointer p = pointer());
//unique_ptr脱离管理的堆内存所有权，并将其返回
pointer release();
//返回堆内存指针（返回原始指针），但不释放unique_ptr所有权（所以这是干嘛的？）
element_type* get();
//字面意思，互相交换所有权
void swap();
//unique_ptr释放时只释放管理的堆内存，对于自定义类型，可以自定义智能指针的资源释放函数来释放
std::unique_ptr<T, DeletorFuncPtr> TName(new T deleteFunc);
```

### std::shared_ptr

可以多指针持有同一资源，每多一个shared_ptr引用计数+1，当引用计数为0时，释放资源，多线程之间使用shared_ptr是安全的。

```c++
std::shared_ptr<int> sp1;
sp1 = std::make_shared<int>(123);
//返回引用计数
sp1.use_count();
//返回是否共享所有权，若为空shared_ptr返回false
bool unique();
```

### std::weak_ptr

没有引用计数，不控制资源生命周期，解决shared_ptr互相引用永不释放的死锁问题

```c++
std::shared_ptr<int> sp1(new int(123));
std::weak_ptr<int> sp2(sp1); //此时引用计数为1
//expired()返回weak_ptr引用对象是否被销毁 true则已被销毁
sp2.expired();
//lock()返回该资源的一个shared_ptr
std::shared_ptr<int> sp3 = sp2.lock();
```

### 注意：

#### 1.一旦一个对象使用了智能指针管理，就不应该用原始指针操作

#### 2.智能指针作为类成员变量时，应优先使用前置声明，减少编译依赖

```c++
#include <memory>

//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h
class A;

class Test
{
public:
    Test();
    ~Test();

private:
    std::unique_ptr<A> m_spA;
};
```



