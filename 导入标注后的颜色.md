```c++
#include <cmath>

        inline bool isEqual(double a, double b) {
            return std::fabs(a - b) < 1e-6; // 设置一个小的阈值进行比较
        }
        if (!isEqual((axis_y->range() / axis_x->range()),(chart_draw_rect.height() / chart_draw_rect.width())) && adaption_){
            qreal scene_width = axis_x->range() >= axis_y->range() 
                ? bounding_rect_.width() + (axis_x->range() / axis_y->range()) * chart_draw_rect.height() - chart_draw_rect.width() 
                : bounding_rect_.width();

            qreal scene_height = axis_x->range() < axis_y->range()
                ? bounding_rect_.height() + (axis_y->range() / axis_x->range()) * chart_draw_rect.width() - chart_draw_rect.height()
                : bounding_rect_.height();
            
            scene()->setSceneRect(QRectF(scene()->sceneRect().topLeft()
                , QSizeF(scene_width, scene_height)));
        }
```

```c++
AQProjectItem
protocol.dest = AQENUM::EPAQProjectPanel;
connect(this, SIGNAL(sig_send_protocol(AQProtocol)), operator_widget, SLOT(slt_receive_event(AQProtocol)));//其他ui连接到operator_panel
```

```c++
//draw poly
QPainterPath result_path;
                    QImage image = QImage(QSize(base_scene_->sceneRect().width(), base_scene_->sceneRect().height()),
                        QImage::Format_RGB32);
                    image.fill(Qt::white);
                    QPainter painter_temp(&image);
                    painter_temp.setPen(QColor(Qt::black));
                    painter_temp.setBrush(QBrush(Qt::black));
                    painter_temp.drawPath(path);
                    painter_temp.drawPath(path2);
                    std::vector<aq::in::Polygon> vector_polygon = aidi::get_cvring_stuct(image);
                    if (vector_polygon.size() < 1) { return path; } //no result, error, return origin path.
                    auto outer_polygon = vector_polygon[0].outer();
                    auto vector_inner_polygon = vector_polygon[0].inners();
                    QPolygonF qt_outer_polygon;
                    for (auto each_point : outer_polygon) { //set outer
                        qt_outer_polygon.append(QPointF(each_point.x, each_point.y));
                    }
                    result_path.addPolygon(qt_outer_polygon);
                    for (int i = 0; i < vector_inner_polygon.size(); i++) {
                        QPolygonF qt_inner_polygon;
                        for (auto each_point : vector_inner_polygon[i]) { //set inner
                            qt_inner_polygon.append(QPointF(each_point.x, each_point.y));
                        }
                        result_path.addPolygon(qt_inner_polygon);
                    }
                    return result_path;
```

```
error: (-215:Assertion failed) 0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows in function 'cv::Mat::Mat'
```

[Q](qpainterpath.html#QPainterPath)PainterPath QPainterPath::intersected(const [QPainterPath](qpainterpath.html#QPainterPath) &*p*) const
