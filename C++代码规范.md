### 1 头文件

为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 `foo` 中的头文件 `foo/src/bar/baz.h` 可按如下方式保护:

```c++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
```

#### 前置声明

- 解决两个类互相包含的问题，也是我们使用前置声明最常解决的问题。
- 解决编译依赖问题，防止某类的更改，导致包含该类其他类型重新编译。

#### typedef

 **任何声明变量的语句前面加上typedef之后，原来是变量的都变成一种类型**。**不管这个声明中的标识符号出现在中间还是最后**.

```c++
typedef int P();
typedef int Q();
class X {
    static P(Q); // 等价于`static int Q()`, Q在此作用域中不再是一个类型
    static Q(P); // 等价于`static int Q(int ())`, 定义了一个名为Q的function
};
```

**typedef 定义的新类型, 使用时可以省略括号.**

```c++
typedef int NUM;
NUM a = 10; // 也可写成`NUM(a) = 10;`
NUM(b) = 12; // 也可写成`NUM b = 12;
```

#### #include

项目内头文件应按照项目源代码目录树结构排列

```c++
#include "base/logging.h"
```

> 1. `dir2/foo2.h` (优先位置, 详情如下)
> 2. C 系统文件
> 3. C++ 系统文件
> 4. 其他库的 `.h` 文件
> 5. 本项目内 `.h` 文件

这种优先的顺序排序保证当 `dir2/foo2.h` 遗漏某些必要的库时， `dir/foo.cc` 或 `dir/foo_test.cc` 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

```c++
#include "foo/public/fooserver.h" // 优先位置

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

------

### 2 作用域

在命名空间的最后注释出命名空间的名字

```c++
// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    ...
    void Foo();
};

} // namespace mynamespace
```

**将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.**

```c++
int i;
i = f(); // 坏——初始化和声明分离
int j = g(); // 好——初始化时声明
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);
vector<int> v = {1, 2}; // 好——v 一开始就初始化
```

#### 静态和全局变量

静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。

禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。

局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效

多线程中的全局变量 (含静态成员变量) 不要使用 `class` 类型 (含 STL 容器), 避免不明确行为导致的 bug.

### 3 类

不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.

- 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.

#### 隐式类型转换

explicit表示取消隐式构造，只能使用有参构造

#### 继承

所有继承必须是 `public` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.

 如果你的类有虚函数, 则析构函数也应该为虚函数.

1. 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;
2. 接口类类名以 `Interface` 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 `protected`;

### 4 函数

排列参数顺序时, 将所有的输入参数置于输出参数之前. 

所有按引用传递的参数必须加上 `const`.

只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致.



C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:

```c++
int foo(int x);
```

C++11 引入了这一新的形式. 现在可以在函数名前使用 `auto` 关键字, 在参数列表之后后置返回类型. 例如:

```c++
auto foo(int x) -> int;
```

### 5 所有权与智能指针

动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.

智能指针是一个通过重载 `*` 和 `->` 运算符以表现得如指针一样的类. 

所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.

### 6 c++特性

**引用：**所有按引用传递的参数必须加上 `const`.

**右值引用：**&&,要高效率地使用某些标准库类型, 例如 `std::unique_ptr`, `std::move` 是必需的,只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 `std::forward` 功能函数. 你可能会使用 `std::move` 来表示将值从一个对象移动而不是复制到另一个对象.

**友元：**通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 

**类型转换：**使用 C++ 的类型转换, 如 `static_cast<>()`. 不要使用 `int y = (int)x` 或 `int y = int(x)` 等转换方式;

**流：**不要使用流, 除非是日志接口需要. 使用 `printf` 之类的代替.

**前置自增/自减：**前置自增 (`++i`) 通常要比后置自增 (`i++`) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 `i` 进行一次拷贝. <u>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</u>

**const：**尽量使用const，如果函数不会修改你传入的引用或指针类型参数, 该参数应声明为 `const`.

**整形：**`<stdint.h>` 定义了 `int16_t`, `uint32_t`, `int64_t` 等整型, 在需要确保整型大小时可以使用它们代替 `short`, `unsigned long long` 等.

**sizeof:**尽可能用 `sizeof(varname)` 代替 `sizeof(type)`.

```c++
Struct data;
Struct data; memset(&data, 0, sizeof(data));
```

**auto：**用 `auto` 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。

一般可以用在长类型名和迭代器上。

`auto` 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 `auto` 变量。

**Boost库：**Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。











